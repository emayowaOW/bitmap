#include <iostream>
#include <deque>
#include "bmp.hpp"

using namespace std;

const int MAX_SIZE = 1000;
bool visited[MAX_SIZE][MAX_SIZE] = { false };

struct pixel {
    int x, y;
    pixel(int x_ = 0, int y_ = 0) : x(x_), y(y_) {}
};

void floodFill(BMP &image, int startX, int startY, color fillColor)
{
    int h = image.get_height();
    int w = image.get_width();

    if (startX < 0 || startX >= w || startY < 0 || startY >= h)
        return;

    color startColor = image.get_pixel(startX, startY);

    // If the start color is already the fill color, nothing to do
    if (startColor.r == fillColor.r && startColor.g == fillColor.g && startColor.b == fillColor.b)
        return;

    // Reset visited
    for (int i = 0; i < h; i++)
        for (int j = 0; j < w; j++)
            visited[i][j] = false;

    deque<pixel> q;
    q.push_back(pixel(startX, startY));
    visited[startY][startX] = true;

    // 4-directional movement
    int dx[] = {1, -1, 0, 0};
    int dy[] = {0, 0, 1, -1};

    while (!q.empty()) {
        pixel temp = q.front();
        q.pop_front();

        color curr = image.get_pixel(temp.x, temp.y);
        if (curr.r == startColor.r && curr.g == startColor.g && curr.b == startColor.b) {
            image.set_pixel(temp.x, temp.y, fillColor);

            for (int i = 0; i < 4; i++) {
                int nx = temp.x + dx[i];
                int ny = temp.y + dy[i];
                if (nx >= 0 && nx < w && ny >= 0 && ny < h && !visited[ny][nx]) {
                    q.push_back(pixel(nx, ny));
                    visited[ny][nx] = true;
                }
            }
        }
    }
}

int main() {
    BMP image("sample2.bmp");
    color fill(255, 0, 0);  // Red color
    floodFill(image, 300, 300, fill);
    image.write("C:\\Users\\erics\\Documents\\GitHub\\Bitmap\\Bitmap\\image2.bmp");
}
